<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    background-color: white;
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
  kbd {
    color: #121212;
  }
</style>
<title>CS 184 Mesh Edit</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Project 2: Mesh Edit</h1>
<h2 align="middle">Olivia Xie</h2>


<div>
    <div align="middle">
        <img src="images/title.png" align="middle" width="50%" />
    </div>
    <br />
    <h2 align="middle">Overview</h2>
    <p>
        In this assignment, I implemented a simple mesh manipulator that can split and flip mesh edges, as well as subdivide a mesh and apply smooth Phong shading. I also apply de Casteljau’s algorithm to implement Bezier curves and surfaces, which are another feature essential in geometric modeling. As a facilitator of the 3D Modeling & Animation DeCal, I found this assignment very interesting and fun as it offered a different perspective on 3D modeling and helped me better understand the mathematical intuition behind the art.
    </p>


    <h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

    <h3 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h3>


    <b>
        Briefly explain de Casteljau's algorithm and how you implemented it in order to evaluate Bezier curves.
    </b>
    <p>
        Casteljau’s algorithm is an algorithm used in computer graphics to implement Bezier curves. More specifically, the algorithm utilizes slope-defining control points between two main points to generate a smooth curve between them.
    </p>
    <p>
        For each edge between the points (edges between the main and its closest control point, as well as the edges between the control points themselves), we create a new point. This point’s location is determined by a variable t, which defines how far away the point should be from its previous/first point in the edge as a fraction of the length of the entire edge. If t = ½, then each new point will be placed in the center of each edge. Then from here, we create new edges between these new points (there should be 1 less edge from the original set) and repeat the same process recursively. By the end, there should be just one edge and one point on this edge. This last point would be a point that sits on the final Bezier curve generated by de Casteljau’s algorithm. Each different t (as a fraction from 0 to 1) results in a final point situated at a different location, and so by modifying t, we can generate all the points that lie on the Bezier curve. We can also create a different Bezier curve by moving the control points (which would affect the slope at each main point).
    </p>

    <br />


    <b>
        Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your choosing. Use this Bezier curve for your screenshots below.
    </b>
    <p>
        Below is a Bezier curve with 6 control points.
    </p>

    <!-- Example of including a single figure -->
    <div align="middle">
        <img src="images/task1_7.png" align="middle" width="50%" />
    </div>
    <br />

    <b>
        Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press <kbd>E</kbd> to step through. Toggle <kbd>C</kbd> to show the completed Bezier curve as well.
    </b>
    <p>
        Note how at each iteration of the evaluation, the new points are being consistently taken at the same t fraction (shown as approximately ⅔) of their respective edges. Additionally, there is one less edge at each step, resulting in the final edge and point that lies on the Bezier curve.
    </p>
    <!-- Example of including multiple figures -->
    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task1.png" align="middle" width="400px" />
                    <figcaption>Level 0</figcaption>
                </td>
                <td>
                    <img src="images/task1_1.png" align="middle" width="400px" />
                    <figcaption>Level 1</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/task1_2.png" align="middle" width="400px" />
                    <figcaption>Level 2</figcaption>
                </td>
                <td>
                    <img src="images/task1_3.png" align="middle" width="400px" />
                    <figcaption>Level 3</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/task1_4.png" align="middle" width="400px" />
                    <figcaption>Level 4</figcaption>
                </td>
                <td>
                    <img src="images/task1_5.png" align="middle" width="400px" />
                    <figcaption>Level 5</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/task1_6.png" align="middle" width="400px" />
                    <figcaption>Final curve</figcaption>
                </td>
            </tr>
        </table>
    </div>
    <br />

    <b>
        Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter \(t\) via mouse scrolling.
    </b>
    <p>
        In this next picture, I move the control points slightly, which results in a slightly different Bezier curve. Changing the t parameter results in a different final point shown on the Bezier curve (here I changed to to about ½).
    </p>
    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task1_9.png" align="middle" width="400px" />
                    <figcaption>Slightly different Bezier curve, with t ~= 2/3</figcaption>
                </td>
                <td>
                    <img src="images/task1_10.png" align="middle" width="400px" />
                    <figcaption>Slightly different Bezier curve, with t ~= 1/2</figcaption>
                </td>
            </tr>
        </table>
    </div>
    <br />


    <h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h3>
    <b>
        Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.
    </b>
    <p>
        The de Casteljau algorithm can extend to Bezier surfaces as well. In the case of a Bezier surface, we consider all curves within the 2D space, parametrized by (u,v) (all curves along the ‘u’ axis, as well as all curves along the ‘v’ axis). One can visualize how we can create a Bezier surface  by stacking a bunch of 1D Bezier curves beside each other to create 3D ‘depth’.
    </p>
    <p>
        To find a point (u,v) on a Bezier surface, the de Casteljau algorithm can be first implemented in the 1D direction; in other words, we can fix one of the parameters—let’s say v—and evaluate all the Bezier curves using input control points for each section along the u-axis. Each interpolated vector output from this evaluation would represent a point on each Bezier curve that we had evaluated. All of these points would have the same shared value for v. Each of these vectors becomes a control point for evaluation along the v-axis, which we then use to perform one more 1D evaluation (this time using u as our scalar interpolation parameter) to output our final interpolated vector.
    </p>
    <br />

    <b>
        Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.
    </b>
    <p>

    </p>
    <div align="middle">
        <img src="images/task2.png" align="middle" width="50%" />
        <figcaption>teapot.bez, evaluated as a Bezier surface</figcaption>
    </div>
    <br />


    <h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

    <h3 align="middle">Part 3: Area-Weighted Vertex Normals</h3>

    <b>
        Briefly explain how you implemented the area-weighted vertex normals.
    </b>
    <p>
        To support smoother Phong shading, I implemented area-weighted vertex normals. For a given center vertex, I iterated through all the neighbor vertices using properties of the half-edge data structure. More specifically, I started with the half-edge of the center vertex and took the vertex of its twin. This vertex corresponds to one of the center vertex’s neighbors. If I repeat the same process on the half-edge of the neighbor vertex, I can find another neighbor of the center vertex (which is also a neighbor of the first neighbor). To find all neighbor vertices, I repeat this process until I return to the original half-edge I started with.
    </p>
    <p>
        Once all neighbor vertices are found, we can then calculate the normals and areas of each face that connects with the center vertex. To find the normal of a face, I took the cross product between two vectors along the edge of the face (with each vertex originating from the center vertex). This is easy to calculate using the list of neighboring vertices prepared beforehand. To find the area of a face, I multiplied the length of the calculated normal vector by ½. Finally, to add the weight of the face area to its corresponding normal, I multiplied the face normal by the face area.
    </p>
    <p>
        To calculate the final normal vector for the center vertex, I summed the weighted normals of each face and performed a final normalization (make it a unit vector) of the resulting vector.
    </p>
    <br />

    <b>
        Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use <kbd>Q</kbd> to toggle default flat shading and Phong shading.
    </b>
    <p>

    </p>
    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task3.png" align="middle" width="400px" />
                    <figcaption>teapot.dae with default flat shading</figcaption>
                </td>
                <td>
                    <img src="images/task3_1.png" align="middle" width="400px" />
                    <figcaption>teapot.dae with Phong shading</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/task3_2.png" align="middle" width="400px" />
                    <figcaption>teapot.dae with default flat shading, at a different angle</figcaption>
                </td>
                <td>
                    <img src="images/task3_3.png" align="middle" width="400px" />
                    <figcaption>teapot.dae with Phong shading, at a different angle</figcaption>
                </td>
            </tr>
        </table>
    </div>

    <br />


    <h3 align="middle">Part 4: Edge Flip</h3>
    <b>
        Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used.
    </b>
    <p>
        The edge flip operation on a mesh involves a series of pointer reassignments. To implement this correctly for an input edge, I reassigned all relevant pointers. These include the halfedges of all vertices, faces, and edges, as well as the vertices, faces, and edges of all halfedges involved. For a given edge in a triangular mesh structure, the edge flip operation involves pointer reassignments for 4 vertices, 2 faces, 5 edges, and 6 halfedges. For each of these elements, I created a variable and drew a diagram to keep track of how each element gets reassigned after an edge flip. Below is a hand drawn diagram of the variables I assigned to each element. As an example, the vertex of halfedge h would get reassigned from hv to ta. Even though not all pointer elements change, I coded all reassignments to avoid any potential bugs.
    </p>
    <div align="middle">
        <img src="images/task4_drawing.png" align="middle" width="50%" />
    </div>

    <br />


    <b>
        Show screenshots of the teapot before and after some edge flips.
    </b>
    <p>

    </p>
    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task4.png" align="middle" width="400px" />
                    <figcaption>teapot.dae before some edge flips</figcaption>
                </td>
                <td>
                    <img src="images/task4_1.png" align="middle" width="400px" />
                    <figcaption>teapot.dae after one edge flip</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/task4_2.png" align="middle" width="400px" />
                    <figcaption>teapot.dae after some more edge flips</figcaption>
                </td>
            </tr>
        </table>
    </div>
    <br />


    <h3 align="middle">Part 5: Edge Split</h3>
    <b>
        Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.
    </b>
    <p>
        The edge split operation splits a given edge on a mesh into two edges. Unlike the edge flip operation, this operation is more involved as it results in the creation of 1 new vertex, 3 new edges, 2 new faces, and 6 new halfedges.
    </p>
    <p>
        The workflow I used to implement edge split is similar to the workflow for the edge flip, where I drew a diagram to assign a variable to each element involved. Like with edge flip, this made it significantly easier to keep track of the pointer reassignments between the elements. The position of the new vertex was calculated using the endpoint vertices of the input edge, hv and tv. Specifically, I used the midpoint formula ((hv + tv) / 2).
    </p>
    <p>
        Below is the diagram I drew to keep track of the variables. Pointer reassignments were made after all variables were assigned.
    </p>
    <div align="middle">
        <tr align="center">
            <td>
                <img src="images/task5_drawing.png" align="middle" width="400px" />
            </td>
            <td>
                <img src="images/task5_drawing1.png" align="middle" width="400px" />
            </td>
        </tr>
    </div>
    <br />


    <b>
        Show screenshots of a mesh before and after some edge splits.
    </b>
    <p>
        Some examples of the edge split operation on the cow.dae mesh:
    </p>
    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task5.png" align="middle" width="400px" />
                    <figcaption>cow.dae before any edge splits</figcaption>
                </td>
                <td>
                    <img src="images/task5_1.png" align="middle" width="400px" />
                    <figcaption>cow.dae after some edge splits</figcaption>
                </td>
            </tr>
        </table>
    </div>

    <br />


    <b>
        Show screenshots of a mesh before and after a combination of both edge splits and edge flips.
    </b>
    <p>
        Edge flip and edge split operations can be performed consecutively to modify the mesh. Below is an example of a mesh after performing a combination of both edge flip and edge split operations:
    </p>
    <div align="middle">
        <img src="images/task5_2.png" align="middle" width="50%" />
        <figcaption>cow.dae after some edge splits and edge flips</figcaption>
    </div>
    <br />

    <h3 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h3>
    <b>
        Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used.
    </b>
    <p>
        To upsample a mesh into one of higher resolution, I implemented loop subdivision. The loop subdivision algorithm subdivides each original triangle into four smaller triangles using a combination of edge splitting and edge flipping. Then, it updates the positions of each vertex using the following weighting scheme:
    </p>
    <p>
        1. If v is a vertex of the original mesh, its new position is calculated using n (degree of v), u (a variable calculated using n), the original position of v, and the sum of positions of all neighboring vertices of v. The specific formula is depicted below.
    </p>
    <center>
        a) v->position = ((1 - (n*u)) * v->position) + (u * (sum of positions of all neighboring vertices))
    </center>
    <center>
        b) u = 3/16 if n=3, and 3/8n otherwise
    </center>
    <p>
        2. If v is a new vertex from edge splitting, its new position is calculated using the original positions of its four neighboring vertices. More specifically, if A and B are the vertices along the split edge and C and D are the vertices connected by the newly formed edges, then:
    </p>
    <center>
        v->position = ((⅜) * (A + B)) + ((⅛) * (C + D))
    </center>
    <br />
    <p>
        The weighting scheme above takes into account the positions of the neighboring vertices and their relation to the vertex in question to calculate the best new position. Note that in the C++ code, the fractions are written with a decimal point (i.e. 3.0 instead of 3) so that the program would interpret the result as a decimal instead of rounding down to 0.
    </p>
    <p>
        In implementing loop subdivision, I performed the following steps in order:
    </p>
    <b>
        <p>
            1. Pre-calculate the new vertex positions for all existing vertices, using the weighting scheme described above
        </p>
        <p>
            2. Pre-calculate the vertex positions for all new vertices that will be created (stored as a variable in each edge that would be split), also using the scheme described above.
        </p>
        <p>
            3. Split each edge of the original mesh using the edge split operation. At this point, I also transfer the new vertex position coordinates from the edge into the new vertex (in v->newPosition, to be later updated along with the positions of the old vertices).
        </p>
        <p>
            4. Flip all new edges that connect an old vertex and a new vertex, using the edge flip operation. These new edges do not include the edges that were split by the new vertices (because technically the original edge splits into two ‘new’ edges in the operation).
        </p>
        <p>
            5. Update the position of all (new and old) vertices by updating the position variables with their stored newPosition variables.
        </p>
    </b>
    <p>
        As mentioned in the above steps, I used a separate variable to store the new position of each variable so that I could update the positions all at once at the very end. This turned out to be very useful in debugging as I could easily comment out this last updating loop to better see what was wrong with my edges when the mesh did not subdivide properly.
    </p>
    <p>
        In addition to using a separate variable for the new position, I also used a boolean variable (isNew) to distinguish between new and old vertices, as well as new and old edges. This was very important in performing steps 1-4, as the operations depend on whether an edge/vertex was part of the original mesh. For instance, in the edge split operation, only two edges and one vertex are set to New per operation.
    </p>
    <p>
        To ensure that loop subdivision works properly on the second function call of upsample and beyond, I reset all of the isNew boolean values to False at the end of the function. This was done so that all edges and vertices will be considered ‘original’ for another round of loop subdivision. If this wasn’t done, only the old, untouched edges would be split over and over again and each new edge from any iteration of subdivision would never be touched again.
    </p>

    <b>
        Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?
    </b>
    <p>
        Below is an example of torus/input.dae after a couple of iterations of loop subdivision. With each iteration, sharp corners and edges become more smoothed out, and the torus becomes a very round ring-like structure.
    </p>
    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task6.png" align="middle" width="400px" />
                    <figcaption>torus/input.dae</figcaption>
                </td>
                <td>
                    <img src="images/task6_1.png" align="middle" width="400px" />
                    <figcaption>torus/input.dae after 1 subdivision loop</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/task6_2.png" align="middle" width="400px" />
                    <figcaption>torus/input.dae after 2 subdivision loops</figcaption>
                </td>
                <td>
                    <img src="images/task6_3.png" align="middle" width="400px" />
                    <figcaption>torus/input.dae after 3 subdivision loops</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/task6_4.png" align="middle" width="400px" />
                    <figcaption>torus/input.dae after 4 subdivision loops</figcaption>
                </td>
            </tr>
        </table>
    </div>
    <br />

    <p>
        If one wants to preserve more of the sharp quality, one can pre-split some edges near the edges that we want to keep sharp (i.e. increase the concentration of edges along the sharp ends). Below, I add some more edges to the torus shape before performing the subdivisions (it looks kind of ugly because of how I split the edges but it demonstrates the conservation of sharpness when the edges are closer to each other).
    </p>
    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task6_5.png" align="middle" width="400px" />
                    <figcaption>modified torus/input.dae with extra edge splits</figcaption>
                </td>
                <td>
                    <img src="images/task6_6.png" align="middle" width="400px" />
                    <figcaption>modified torus/input.dae after 1 subdivision loop</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/task6_7.png" align="middle" width="400px" />
                    <figcaption>modified torus/input.dae after 2 subdivision loops</figcaption>
                </td>
                <td>
                    <img src="images/task6_8.png" align="middle" width="400px" />
                    <figcaption>modified torus/input.dae after many more subdivision loops</figcaption>
                </td>
            </tr>
        </table>
    </div>
    <br />


    <b>
        Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects.
    </b>
    <p>
        When performing loop subdivision on the cube, it becomes slightly asymmetric after a couple of subdivisions. This is because of how not all vertices can have degree 6, if it is topologically equivalent to a sphere. To reason this, if there are T triangles, then there are (3/2)*T edges because each edge is part of 2 triangles. We can plug this into the Euler Convex Polyhedron formula (2 = T - E + V) to obtain the number of triangles T = 2V - 4. However, if all vertices had 6 triangles (and hence 6 edges), then T = 2V (since then E would be equal to (6/2)V, and plugging in E = (3/2)T yields T = 2V). However, we just stated earlier that T = 2V - 4. Therefore, it is not possible for all vertices to have degree 6, resulting in a slightly asymmetric mesh when we subdivide.
    </p>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/cube.png" align="middle" width="400px" />
                    <figcaption>original cube.dae</figcaption>
                </td>
                <td>
                    <img src="images/cube1.png" align="middle" width="400px" />
                    <figcaption>cube after 1 subdivision loop</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/cube2.png" align="middle" width="400px" />
                    <figcaption>cube after 2 subdivision loops</figcaption>
                </td>
                <td>
                    <img src="images/cube3.png" align="middle" width="400px" />
                    <figcaption>cube after 3 subdivision loop</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/cube4.png" align="middle" width="400px" />
                    <figcaption>cube after 4 subdivision loops</figcaption>
                </td>
                <td>
                    <img src="images/cube_compare_asymm1.png" align="middle" width="400px" />
                    <figcaption>cube seen from a different angle (note the asymmetry)</figcaption>
                </td>
            </tr>
        </table>
    </div>

    <p>
        To try and alleviate this issue in cube.dae, I attempt to preprocess the cube by making the degrees as even as possible across all vertices. I do this by splitting two edges and flipping the other edges so that each vertex is of degree 5 except for two (which are of degree 4). When applying subdivisions, this results in the cube looking marshmallow-shaped, but it is symmetric across one axis (as opposed to being asymmetric without any preprocessing).
    </p>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/cubefix.png" align="middle" width="400px" />
                    <figcaption>cube.dae with additional edge splits and flips</figcaption>
                </td>
                <td>
                    <img src="images/cubefix1.png" align="middle" width="400px" />
                    <figcaption>modified cube after a couple of subdivisions</figcaption>
                </td>
            </tr>
            <tr align="center">
                <td>
                    <img src="images/cubefix2.png" align="middle" width="400px" />
                    <figcaption>modified cube after a couple of subdivisions, from a different angle</figcaption>
                </td>
            </tr>
        </table>
    </div>

    <br />

    </table>


</div>
    </div></body>
</html>